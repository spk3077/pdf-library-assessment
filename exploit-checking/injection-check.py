"""
File: injection-check.py
Assignment: MS Capstone
Lanuguage: python3
Author: Sean Kells <spk3077@rit.edu>
Purpose: Test generated PDFs for PDF Injection (PDF Injection & Image Escape)
"""
import sys
import re
from os import listdir
from os.path import join, dirname, basename
import shutil


import pikepdf
from PyPDF2 import PdfReader
from PyPDF2.errors import PdfStreamError, PdfReadError


sys.path.insert(0, dirname(__file__) + '/../payloads')
from py_payloads import escape_seq

PAYLOADS: set = {s.encode("utf-8") for s in set(escape_seq)}
DIR_TO_PDFS: str = "/../environments/dompdf/php/pdfs"
# DIR_TO_PDFS: str = "/../environments/itext/pdfs"

IGNORE_OUTPUT: set = {
'hackerÂ©', 
'hackerÃ›', 
'hacker©', 
'hackerÜ®', 
'hacker Æ©', 
'hackerï¿½', 
'hackerÜ¢', 
'hackerÊ©', 
'hackeró¶¶œ', 
'hackerÏ›', 
'hackerá»¨', 
'hackerð “£', 
'hackerð „¸', 
'hackerÃ©', 
'hackerâœ?', 
'hackerðš’©', 
'hackerâ?©', 
'hackerÎ©', 
'hackerâŸº', 
'hackerð •©', 
'hackerâš¤', 
'hacker Ü‘', 
'hackerð ™©', 
'hackerâƒ©', 
'hackerð’¢©', 
'hackerâ“©', 
'hackerð’©¥', 
'hackerâ©¾', 
'hackerð„¸', 
'hackerðš‚©', 
'hackerá»©',
'hacker?',
'hacker ?'
}

def find_all_indices(substring, input_string) -> list:
    """
    find_all_indices() get all indexes of the substring within the input_string

    :param substring: substring to search for inside the input_strings
    :param input_string: string to search
    :return: List of indexes of the substring
    """
    return [m.start() for m in re.finditer(re.escape(substring), input_string)]


def get_files() -> set:
    """
    get_files retrieves all the filenames of PDFs within the DIR_TO_PDFS directory

    :return: Set containing PDF file paths
    """
    ret: set = set()
    dir: str = dirname(__file__) + DIR_TO_PDFS

    for filename in listdir(dir):
        if filename == "README.md":
            continue

        ret.add(join(dir, filename))

    return ret


def check_injection(injection: bytes) -> bool:
    """
    check_injection checks if the injected content successfully escaped the grasp of it's associated structure in the PDF

    :param injection: bytes to assess if escaped or not
    :return: True if injection is likely present, False if injection unsuccessful
    """
    if injection in PAYLOADS:
        return False
    
    elif injection.rfind(b'</a>') != -1:
        return False
    
    elif injection.rfind(b'endstream') != -1:
        return False

    return True


def check_after_paren(pdf_content: bytes, injection: bytes) -> bool:
    """
    check_after_paren checks if the character after the injected content is an expected character

    :param pdf_content: The content of the PDF file
    :param injection: the injection we are searching for in the PDF file path
    :return: True if content afterwards is unexpected, False if expected
    """
    matches = re.finditer(rb"(?<!\\)(?:\\\\)*\)", pdf_content[pdf_content.find(injection):])
    for match in matches:
        post_paren_char: bytes = pdf_content[pdf_content.find(injection):][match.end() : match.end() + 1]
        if post_paren_char == b'\n':
            return False
        elif post_paren_char == b' ':
            return False
        elif post_paren_char == b'>':
            return False

    return True


def check_pdf_valid(file_path: str) -> tuple[bool, str]:
    """
    check_pdf_valid checks if the inputted file_path is a valid PDF

    :param file_path: the file_path 
    :return: Tuple(True if input PDF is valid, false if invalid | string for rationale why invalid)
    """
    try:
        pdf_content: bytes = b''
        with open(file_path, 'rb') as f:
            pdf_content = f.read()

        with open(file_path, 'rb') as f:
            pyPDFreader = PdfReader(f, True)
            pyPDFpage = pyPDFreader.pages[0]
            pyPDFimages = pyPDFpage.images

            # If the PDF Structure broke
            if not pyPDFreader.metadata:
                return False, "METDATA"
            
            # If DOGTEST Text can be read
            elif pyPDFpage.extract_text().find("DOGTEST") == -1:
                return False, "DOGTEST"

            # If injection is in text
            full_text: str = pyPDFpage.extract_text()
            if '<a>' not in full_text and '</a>' not in full_text and 'endstream' not in full_text:
                inject_index: list = find_all_indices('hacker', full_text)
                for i in range(len(inject_index)):
                    if len(inject_index) >= i + 2:
                        text_inject: str = full_text[inject_index[i]:inject_index[i+1]].rstrip()
                    else:
                        text_inject: str = full_text[inject_index[i]:full_text.find("DOGTEST")].rstrip()

                    # TEXT_INJECT TESTS
                    if text_inject not in IGNORE_OUTPUT and text_inject.encode("utf-8") not in PAYLOADS:
                        return False, "NOT_PAYLOAD_TEXT"

        # If Annotations were injected into
        uri_matches = re.finditer(rb'\/URI \((?:[^\\)]+|\\.)*\)', pdf_content)
        for match in uri_matches:
            uri: bytes = match.group(0)[6:-1]

            if uri == b'hacker':
                return False, "HACKER"

            elif check_injection(uri) and check_after_paren(pdf_content, uri):
                return False, "AFTER_PAREN"
            
        text_matches = re.finditer(rb'Text\/T\((?:[^\\)]+|\\.)*\)', pdf_content)
        for match in text_matches:
            text: bytes = match.group(0)[7:-1]

            if text == b'hacker':
                return False, "HACKER"

            elif check_injection(text) and check_after_paren(pdf_content, text):
                return False, "AFTER_PAREN"


        pikeFile = pikepdf.Pdf.open(file_path)
        pikePage = pikeFile.pages[0]
        pikeImages = pikePage.images
        if pikePage.get("/Annots") != None:
            for annot in pikePage.get("/Annots"):
                if annot.get("/Subtype") == "/Link" and not annot.get("/A").get("/URI"):
                    return False, "NO_URI"
                
                elif annot.get("/Subtype") == "/Text" and not annot.get("/T"):
                    return False, "NO_TEXT"


        return True, "OK"
    except Exception as ex:
        if str(ex) == "Image data is not rectangular":
            return True, "OK"

        return False, "ERROR"


def main():
    """
    main is primary function when executing the Python script.

    :return: Nothing
    """
    files: set = get_files()

    ret: dict = {}
    for file in files:
        valid, status = check_pdf_valid(file)
        if not valid:
            ret[file] = status
            shutil.copy(file, dirname(__file__) + "/../examples/" +  basename(file))

    with open(DIR_TO_PDFS.split('/')[3] + '.txt', 'w') as f:
        count: int = 1
        for key in ret.keys():
            f.write(str(count) + "\n")
            f.write("The file, " + key[key.rfind('/') + 1:] + " was found to be invalid\n")

            # Rationale for Suspicion
            if ret[key] == "METDATA":
                f.write("Rationale: Metadata Failure")

            elif ret[key] == "DOGTEST":
                f.write("Rationale: DOGTEST not in PDF")

            elif ret[key] == "NOT_PAYLOAD_TEXT":
                f.write("Rationale: Text input not in payloads")

            elif ret[key] == "HACKER":
                f.write("Rationale: prefix only present")

            elif ret[key] == "AFTER_PAREN":
                f.write("Rationale: Unexpected content post parenthesis")

            elif ret[key] == "NO_URI":
                f.write("Rationale: URI Annot did not load")

            elif ret[key] == "NO_TEXT":
                f.write("Rationale: TEXT Annot did not load")

            elif ret[key] == "ERROR":
                f.write("Rationale: Error Raised")

            else:
                f.write("Rationale: Missing")
                print("MISSING RATIONALE")

            f.write("\n\n-----------------------------------------------------\n")
            count += 1


    print("Total Count: " + str(len(ret)))

if __name__ == "__main__":
    main()